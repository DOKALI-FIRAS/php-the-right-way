--- 
title: الأخطاء
isChild: true
anchor:  errors
---

## الأخطاء {#errors_title}

في الكثير من لغات البرمجة التي تعتمد بكثافة على الإستثناءات "Exceptions" عندما يحدث خطأ ما سوف يتم القاء إستثناء.
فهذه هي الطريقة المعتمدة لعمل الأشياء، ولكن لغة PHP لا تعتمد بكثافة على الإستثناءات. ولكن توجد إستثناءات بداخلها
والعديد من الدوال الجوهرية بدأت فعلياً باستخدام الإستثناءات ثم التعامل بالكائنات، فالعديد من PHP نفسها تحاول ان
تواصل العمل بغض النظر عما يحدث، إلا إذا حدث خطأ ما.

مثلاً:

{% highlight console %}
$ php -a
php > echo $foo;
Notice: Undefined variable: foo in php shell code on line 1
{% endhighlight %}

هذه مجرد ملاحظة ، PHP ستواصل العمل ولن تتوقف. وهذا قد يربك المطورين من لغات اخرى معتمدة على الإستثناءات بكثافة،
لأنه عند استخدام متغير غير معرف في لغة Python مثلاً سيقوم برمي إستثناء:

{% highlight console %}
$ python
>>> print foo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'foo' is not defined
{% endhighlight %}

الإختلاف الحقيقي فقط هو أن لغة Python سوف تتوقف لأي شي حتى ولو كان صغيراً، إذاً سيكون المبرمج متأكداً جداً من أي مشكلة قد تحدث
سيتم إكتشافها، بالمقابل PHP ستواصل قدماً في المعالجة إلا إذا حدث شيء كبير، عندها ستقوم برمي خطأ وتقرير هذا الخطاً.

### شدة الخطأ

لدى PHP عدة مستويات لشدة الخطأ. يوجد ثلاث أنو معروفة من أنواع رسائل الخطأ والملاحظات والتحذيرات.
هنالك عدة مستويات مختلفة من الشدة: `E_ERROR` و `E_NOTICE` و `E_WARNING`. الأولى هي الأخطاء الفادحة التي تحدث أثناء
التنفيذ وغالباً ما تسبب فشل في تنفيذ المصدر ويتوجب عليك فحص هذا الخطأ حتى تتمكن من إكمال التنفيذ لأن PHP ستقوم بإيقاف
التنفيذ. الثانية وهي رسائل نصحية تسبب المصدر في ظهورها ربما تتسبب أو قد لا تتسبب في حدوث خطأ اثناء تنفيذ المصدر، ولكن
لن توقف PHP التنفيذ. والأخيرة هي أخطاء غير فادحة ولن يتوقف التنفيذ

هنالك نوع آخر من رسائل التقرير بالخطأ في مرحلة البناء والتجميع وهي `E_STRICT`. هذه الرسائل تستخدم لإقتراح تغيير في
المصدر لتأكيد انه يقوم بنجاح بالتشغيل البيني و متوافق مع الإصدارات القادمة من PHP

### تغيير طريقة PHP لتقرير الأخطاء

يمكن تغيير طريقة تقرير الأخطاء باستخدام ضبط PHP أو/و عن طريق تنفيذ دوال. باستخدام الدالة المدمجة `error_reporting()`
يمكنك أن تحدد مستوى تقرير الأخطاء والمدة التي يتم فيها تنفيذ المصدر بارسال واحدة من ثوابت تقرير الأخطاء، بمعنى أنه
يمكنك أن تحدد ما إذا كنت تريد أن تحصل على تقارير أخطاء وتحذيرات من دون ملاحظات فسيكون عليك ان يكون الضبط كالآتي:

{% highlight php %}
<?php
error_reporting(E_ERROR | E_WARNING);
{% endhighlight %}

يمكنك أيضاً التحكم ما إن تظهر تلك الأخطاء على الشاشة أم لا (مفيدة في مرحلة التطوير)، وهل يتم تقييدها أم لا (مفيدة في العمل النهائي).
للمزيد من المعلومات قم بزيارة [تقرير الأخطاء][errorreport].

### كبح الأخطاء الداخلي

يمكنك إخبار PHP لكي يقوم بكبح أخطاء معينة باستخدام رمز التحكم بالأخطاء `@`. كل ما عليك أن تضع هذه العلامة في بداية
الجملة البرمجية، سينتج من هذا أن أي خطأ ينجم من تلك الجملة فسيتم كبحه.

{% highlight php %}
<?php
echo @$foo['bar'];
{% endhighlight %}

سيقوم هذا بطباعة `$foo['bar']` إذا كان موجوداً، ولكن ببساطة يسقوم بإرجاع القيمة الفارغة NULL ولا شيء سيتم طباعته، وذلك
في أي ما ان كان المتغير `$foo` أو الفهرس `'bar'` غير موجود. من غير رمز التحكم هذه الجملة قد تنتج أي من هاتين الرسالتين:
`PHP Notice: Undefined variable: foo` أو `PHP Notice: Undefined index: bar`.

قد تبدو هذه فكرة جيدة ولكن هنالك مفاضلات غير مرغوب فيها. تقوم PHP بالتعامل مع الجمل التي تحتوي على الرمز `@` بطريقة أقل
كفاءة من تلك التي لا تحتوي على الرمز `@`. التمثيل المسبق هو جذر قيم البرمجة ولكن إذا كان الأداء مهم لتطبيقك/مكتبتك فمن المهم
أن تعلم النقص الذي يسببه الرمز `@` في الأداء.

وأيضاً يقوم رمز كبح الخطأ بإبتلاع الخطأ **تماماً**. لن يظهر الخطأ ولن يتم تسجيله. في أنظمة PHP على بيئة العمل النهائية لا
تستطيع أن تتحكم بتعطيل وظيفة هذا الرمز. قد ترى بعض الأحيان أنه قد يكون خطأ ما غير مؤذٍ أو غير مهم على الإطلاق ولا يؤثر في شيء
فتفضل أن يتم كبح تقريره وعرضه.

كلما ابتعدت عن إستخدام كبح الأخطاء كلما كان أفضل. فمثلاً المثال أعلاه يمكن إعادة كتابته كالاتي بطريقة صحيحة:

{% highlight php %}
<?php
echo isset($foo['bar']) ? $foo['bar'] : '';
{% endhighlight %}

هنالك حالة قد يكون كبح الأخطاء فيها شيء منطقي، كاستخدام الدالة `fopen()` عندما تفشل في فتح الملف المطلوب. يتوجب عليك فحص
وجود الملف أولاً قبل القيام بفتح، ولكن ماذا إذا تم حذف الملف بعد نجاح عملية وقبل أن تنفذ `fopen()` (ربما تكون مستحيلة، ولكن
قد تحدث) عندها ستقوم الدالة بإرجاع القيمة false _و_ رمي خطأ. في الحقيقة هذا شيء يتوجب على PHP أن تقوم بحله ولكن هذه الحالة
قد تكون الوحيدة الصالحة لإستخدام كبح الأخطاء.

كما ذكرنا سابقاً انه لا يوجد طريقة لنظام PHP أن يقوم بمنع رمز الكبح ولكن [Xdebug] بها ضبط `xdebug.scream` ini وستقوم بتعطيل
رمز الكبح. يمكن تفعيل هذا الخيار عن طريق ملف ضبط PHP `php.ini` بالأتي:

{% highlight ini %}
xdebug.scream = On
{% endhighlight %}

يمكن أيضاً إسناد القيمة وتفعيل الضبط أثناء التشغيل باستخدام دالة `ini_set`.

{% highlight php %}
<?php
ini_set('xdebug.scream', '1');
{% endhighlight %}

لاحقة PHP "[Scream]" توفر وظيفة مشابهة لما توفره Xdebug ولكن ضبط الأولى يسمى `scream.enabled`

هذا مفيد خاصةً عندما تقوم بفحص المصدر وتتوقع أن هنالك أخطاء قد تكون كبحت. قم باستخدام Scream بحرص وكأداة فحص مؤقتة.
هنالك الكثير من مكتبات PHP التي لن تعمل برمز كبح الأخطاء.


* [Error Control Operators]
* [SitePoint]
* [Xdebug]
* [Scream]


### إستثناء الخطأ

يمكن لPHP أن تكون لغة معتمدة على الإستثناءات وتحتاج للقليل من الأسطر لكي تتم عملية التحويل. فعلياً يمكنك رمي أخطاء على شكل
إستثناءات باستخدام كلاس `ErrorException` فهو يقوم بإستمداد كلاس `Exception`.

هذه ممارسة متعارف عليها يتم تطبيقها من قبل الكثير من أطر العمل الحديثة مثل Symfony و Laravel. في كل من طور التطوير أو طور كشف الأخطاء. كلا الإطارين يقومان بعرض *مسلسل مكدس التنفيذ*.
هنالك عدة حزم متوافرة لإظهار وإدارة الأخطاء بشكل أفضل مثل حزمة [Whoops!] فهي تأتي بشكل افتراضي مع إطار عمل Laravel ، ويمكن استخدامها أيضا مع أي اطار عمل اخر.

باستخدام رمي الأخطاء على شكل إستثناءات في عملية التطوير يمكنك التعامل بشكل أفضل من النتائج التقليدية، وإذا رأيت إستثناء
في عملية التطوير يمكنك تغطيتها في جملة catch مع تعليمات تفصيلية لكيفية التعامل مع هذه الحالة. كل إستثناء تقوم بإمساكه
يجعل من برنامجك أكثر ثباتاً وفعالية.

للمزيد من المعلومات والتفاصيل وكيفية استخدام `ErrorException` مع طريقة التعامل مع الأخطاء
[ErrorException Class][errorexception].

* [Error Control Operators]
* [Predefined Constants for Error Handling]
* [`error_reporting()`][error_reporting]
* [Reporting][errorreport]


[errorreport]: /#error_reporting
[Xdebug]: http://xdebug.org/docs/basic
[Scream]: http://php.net/book.scream
[Error Control Operators]: http://php.net/language.operators.errorcontrol
[SitePoint]: http://www.sitepoint.com/
[Whoops!]: http://filp.github.io/whoops/
[errorexception]: http://php.net/class.errorexception
[Predefined Constants for Error Handling]: http://php.net/errorfunc.constants
[error_reporting]: http://php.net/function.error-reporting
